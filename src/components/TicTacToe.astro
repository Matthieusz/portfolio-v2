---
// Tic-Tac-Toe game component - Player (X) vs Computer (O)
---

<div
  id="tictactoe"
  class="bg-card border-border relative flex h-full flex-col rounded-lg border p-4"
>
  <div class="mb-3 flex items-center justify-between">
    <h3
      class="text-muted-foreground flex items-center gap-2 text-xs font-medium tracking-wider uppercase"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="20"
        height="20"
        viewBox="0 0 24 24"
        fill="var(--primary)"
        class="icon icon-tabler icons-tabler-filled icon-tabler-device-gamepad"
        ><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path
          d="M20 5a3 3 0 0 1 3 3v8a3 3 0 0 1 -3 3h-16a3 3 0 0 1 -3 -3v-8a3 3 0 0 1 3 -3zm-12 4l-.117 .007a1 1 0 0 0 -.883 .993v1h-1a1 1 0 0 0 -1 1l.007 .117a1 1 0 0 0 .993 .883h1v1a1 1 0 0 0 1 1l.117 -.007a1 1 0 0 0 .883 -.993v-1h1a1 1 0 0 0 1 -1l-.007 -.117a1 1 0 0 0 -.993 -.883h-1v-1a1 1 0 0 0 -1 -1m10 3a1 1 0 0 0 -1 1v.01a1 1 0 0 0 2 0v-.01a1 1 0 0 0 -1 -1m-3 -2a1 1 0 0 0 -1 1v.01a1 1 0 0 0 2 0v-.01a1 1 0 0 0 -1 -1"
        ></path></svg
      >
      Tic Tac Toe
    </h3>
    <button
      id="ttt-reset"
      class="text-muted-foreground hover:text-foreground text-xs transition-colors"
    >
      Reset
    </button>
  </div>

  <div
    id="ttt-status"
    class="text-foreground mb-3 text-center text-sm font-medium"
  >
    Your turn (X)
  </div>

  <div class="flex flex-1 items-center justify-center">
    <div
      id="ttt-board"
      class="grid aspect-square w-full max-w-45 grid-cols-3 gap-1"
    >
      {
        [0, 1, 2, 3, 4, 5, 6, 7, 8].map((i) => (
          <button
            data-cell={i}
            class="ttt-cell bg-muted hover:bg-muted/80 text-foreground flex aspect-square items-center justify-center rounded text-2xl font-bold transition-colors disabled:cursor-not-allowed"
          />
        ))
      }
    </div>
  </div>

  <div class="mt-3 flex justify-center gap-4 text-xs">
    <span class="text-muted-foreground">
      You: <span id="ttt-player-score" class="text-foreground font-medium"
        >0</span
      >
    </span>
    <span class="text-muted-foreground">
      AI: <span id="ttt-ai-score" class="text-foreground font-medium">0</span>
    </span>
  </div>
</div>

<style>
  .ttt-cell.x {
    color: hsl(var(--primary));
  }
  .ttt-cell.o {
    color: hsl(var(--destructive, 0 84% 60%));
  }
  .ttt-cell.winner {
    animation: pulse 0.5s ease-in-out 2;
  }
  @keyframes pulse {
    0%,
    100% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.1);
    }
  }
</style>

<script>
  type Player = "X" | "O" | null;
  type Board = Player[];

  const WINNING_COMBOS = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8], // rows
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8], // cols
    [0, 4, 8],
    [2, 4, 6], // diagonals
  ];

  let board: Board = Array(9).fill(null);
  let gameOver = false;
  let playerScore = 0;
  let aiScore = 0;

  const cells = document.querySelectorAll<HTMLButtonElement>(".ttt-cell");
  const statusEl = document.getElementById("ttt-status")!;
  const resetBtn = document.getElementById("ttt-reset")!;
  const playerScoreEl = document.getElementById("ttt-player-score")!;
  const aiScoreEl = document.getElementById("ttt-ai-score")!;

  function checkWinner(b: Board): { winner: Player; combo: number[] | null } {
    for (const combo of WINNING_COMBOS) {
      const [a, c, d] = combo;
      if (b[a] && b[a] === b[c] && b[a] === b[d]) {
        return { winner: b[a], combo };
      }
    }
    return { winner: null, combo: null };
  }

  function isBoardFull(b: Board): boolean {
    return b.every((cell) => cell !== null);
  }

  function getEmptyCells(b: Board): number[] {
    return b.map((v, i) => (v === null ? i : -1)).filter((i) => i !== -1);
  }

  // Minimax with limited depth to make AI beatable
  function minimax(
    b: Board,
    depth: number,
    isMax: boolean,
    maxDepth: number,
  ): number {
    const { winner } = checkWinner(b);
    if (winner === "O") return 10 - depth;
    if (winner === "X") return depth - 10;
    if (isBoardFull(b) || depth >= maxDepth) return 0;

    const empty = getEmptyCells(b);

    if (isMax) {
      let best = -Infinity;
      for (const i of empty) {
        b[i] = "O";
        best = Math.max(best, minimax(b, depth + 1, false, maxDepth));
        b[i] = null;
      }
      return best;
    } else {
      let best = Infinity;
      for (const i of empty) {
        b[i] = "X";
        best = Math.min(best, minimax(b, depth + 1, true, maxDepth));
        b[i] = null;
      }
      return best;
    }
  }

  function getAIMove(): number {
    const empty = getEmptyCells(board);
    if (empty.length === 0) return -1;

    // Make AI beatable: 30% chance to make a random move
    if (Math.random() < 0.3) {
      return empty[Math.floor(Math.random() * empty.length)];
    }

    // Otherwise use minimax with limited depth
    let bestScore = -Infinity;
    let bestMove = empty[0];
    const maxDepth = 4; // Limit depth for imperfect play

    for (const i of empty) {
      board[i] = "O";
      const score = minimax(board, 0, false, maxDepth);
      board[i] = null;
      if (score > bestScore) {
        bestScore = score;
        bestMove = i;
      }
    }

    return bestMove;
  }

  function updateCell(index: number, player: Player) {
    const cell = cells[index];
    cell.textContent = player || "";
    cell.classList.remove("x", "o");
    if (player) {
      cell.classList.add(player.toLowerCase());
      cell.disabled = true;
    }
  }

  function highlightWinner(combo: number[]) {
    for (const i of combo) {
      cells[i].classList.add("winner");
    }
  }

  function endGame(winner: Player) {
    gameOver = true;
    cells.forEach((c) => (c.disabled = true));

    if (winner === "X") {
      playerScore++;
      playerScoreEl.textContent = String(playerScore);
      statusEl.textContent = "You win! ðŸŽ‰";
    } else if (winner === "O") {
      aiScore++;
      aiScoreEl.textContent = String(aiScore);
      statusEl.textContent = "AI wins! ðŸ¤–";
    } else {
      statusEl.textContent = "It's a draw! ðŸ¤";
    }
  }

  function makeMove(index: number, player: Player) {
    if (board[index] || gameOver) return false;
    board[index] = player;
    updateCell(index, player);
    return true;
  }

  function handlePlayerMove(index: number) {
    if (!makeMove(index, "X")) return;

    const { winner, combo } = checkWinner(board);
    if (winner) {
      highlightWinner(combo!);
      endGame(winner);
      return;
    }

    if (isBoardFull(board)) {
      endGame(null);
      return;
    }

    // AI's turn
    statusEl.textContent = "AI thinking...";
    cells.forEach((c) => (c.disabled = true));

    setTimeout(() => {
      const aiMove = getAIMove();
      if (aiMove !== -1) {
        makeMove(aiMove, "O");

        const { winner: aiWinner, combo: aiCombo } = checkWinner(board);
        if (aiWinner) {
          highlightWinner(aiCombo!);
          endGame(aiWinner);
          return;
        }

        if (isBoardFull(board)) {
          endGame(null);
          return;
        }
      }

      statusEl.textContent = "Your turn (X)";
      cells.forEach((c, i) => {
        if (!board[i]) c.disabled = false;
      });
    }, 300);
  }

  function resetGame() {
    board = Array(9).fill(null);
    gameOver = false;
    cells.forEach((c) => {
      c.textContent = "";
      c.classList.remove("x", "o", "winner");
      c.disabled = false;
    });
    statusEl.textContent = "Your turn (X)";
  }

  // Event listeners
  cells.forEach((cell, index) => {
    cell.addEventListener("click", () => handlePlayerMove(index));
  });

  resetBtn.addEventListener("click", resetGame);
</script>
